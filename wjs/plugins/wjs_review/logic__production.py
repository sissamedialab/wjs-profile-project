"""Logic classes for production-related actions & co.

This module should be *-imported into logic.py
"""

import dataclasses
from typing import Optional

from django.contrib.auth import get_user_model
from django.http import HttpRequest
from plugins.typesetting.models import GalleyProofing, TypesettingAssignment
from submission.models import Article
from utils.logger import get_logger

logger = get_logger(__name__)
Account = get_user_model()


# https://gitlab.sissamedialab.it/wjs/specs/-/issues/667
@dataclasses.dataclass
class AssignTypesetter:
    """Assign a typesetter to an article.

    This can be used either when
    - typesetter takes a paper in charge
    - system automagically assigns a typesetter
    """

    article: Article
    typesetter: Account
    request: HttpRequest  # ???
    assignment: Optional[TypesettingAssignment] = None

    def run(self) -> TypesettingAssignment:
        pass

        # _check_conditions
        #   - typesetter:Account must have role typesetter
        #   - article.articleworkflow must be in the right state
        #   - ...

        # _assign_typesetter
        #  - create TypesettingAssignment; see:
        #    - typesetting.views.typesetting_assign_typesetter
        #    - typesetting.forms.AssignTypesetter
        #  - TBD: create production.models.TypesettingTask
        #  - ✗ TBD: create TypesettingClaim
        #  - ✗ TBD: create TypesettingAssignment.corrections

        # _log_opertation(context...)
        #   - write to typ only if system is doing the assignment


# https://gitlab.sissamedialab.it/wjs/specs/-/issues/671 (drop this comment)
@dataclasses.dataclass
class RequestProofs:
    """The typesetter completes a typesetting round and requires proofreading from the author."""

    # Roughly equivalent Janeway's "Typesetting task completed"
    # (do not confuse with "typesetting complete", that moves the article to pre-publication)

    typesetting_assignment: TypesettingAssignment
    request: HttpRequest  # ???
    assignment: Optional[TypesettingAssignment] = None

    def run(self) -> GalleyProofing:
        """Move the article state to PROOFREADING and notify the author."""
        pass

    # _check_conditions
    #   - ...
    #   - galleys are present (? TBV: AFAICT an article's galleys are
    #                          all typeset_files from all typesetting assignments)
    #   - ...

    # _create_proofing_assignment
    #   - prooreader = article.correspondence_author
    #   - with due date (different defaults if typ-round==1 or typ-rount>1)
    #   - with multi-template message? (see US ID:NA row:260 order:235)
    #     - similar to editor-selects-reviewer but with more template messages to choose from


@dataclasses.dataclass
class SendProofs:
    # TBD: typetting plugin has a maybe-similar concept of "corrections"
    """The author sends a request for corrections (or a can-be-published green light).

    E.g.:
    - a text with some notes ("in pg.X l.Y, change A with B")
    - a file with some notes
    - (future) a patch-like something generated by on-premises Overleaf
    - ...
    """

    article: Article
    assignment: TypesettingAssignment  # OR GalleyProofing
    request: HttpRequest  # ???

    def run(self) -> GalleyProofing:
        # OR: -> proofing.ProofingAssignment
        # But! I think typesetting plugins obsoletes proofing
        pass

    # TBD: _bump_round of same typesetting assignment or create a new one?
    #   - probably best place to bump the round number is typesetter-side:
    #     - when typ takes in charge -> round 1
    #     - when proofs are in, typ can ask for another round
    # The choosen solution must allow us to keep track of changes that the typ makes to the typeset files in each round
    # (similar to versioning the files)
